# 阿尔法-贝塔剪枝|人工智能

> 原文:[https://www.tutorialandexample.com/alpha-beta-pruning/](https://www.tutorialandexample.com/alpha-beta-pruning/)

阿尔法-贝塔剪枝是极大极小算法的高级版本。极大极小策略的缺点是，它深入探索树中的每个节点，以提供所有路径中的最佳路径。这增加了它的时间复杂度。但正如我们所知，性能指标是任何优化算法的首要考虑因素。因此，α-β剪枝通过更少地探索搜索树的节点来减少极大极小策略的这一缺点。

alpha-beta 修剪中使用的方法是,**通过探索更少数量的节点来切断搜索**。它的动作和极大极小算法一样，但是它使用修剪技术来修剪不想要的分支(在对抗性搜索中讨论)。Alpha-beta 剪枝作用于两个阈值，即**？【阿尔法】**和**？(beta)。**

*   **？:**是一个 **MAX** 玩家所能拥有的最好的最高值。是下限，代表负无穷大值。
*   **？:**这是一个 **MIN** 玩家可以拥有的最佳最低值。它是代表正无穷大的上界。

所以每个 MAX 节点都有？-value，永不减少，每个 MIN 节点有？-价值，永远不会增加。

**注意:** Alpha-beta 剪枝技术可以应用于任何深度的树，可以轻松剪枝整个子树。

**阿尔法-贝塔剪枝工作**

考虑下面这个博弈树的例子，其中 **P** 和 **Q** 是两个玩家。这个游戏将交替进行，即一次一次地进行。让， **P** 成为试图通过最大化获胜机会来赢得游戏的玩家。问是玩家将试图最小化 **P'** 的获胜机会。这里，**？**代表节点的最大值，也是 **P** 的值。**？**将代表节点的最小值，这将是 **Q** 的值。

<figure class="aligncenter">![alpha beta pruning](../Images/2c215ab7dadc2fa3c05dee6cdf1ac0a8.png)</figure>

*   任何一个玩家都可以开始游戏。遵循 DFS 命令，玩家将选择一条路径，并将到达其深度，即，在那里他将找到**终端**值。
*   如果游戏由玩家 P 开始，他将选择最大值，以便用最大效用值增加其获胜机会。
*   如果这个游戏是由玩家 Q 开始的，他会选择最小的值，以便用可能的最小效用值来减少 A 的获胜机会。
*   两人将轮流玩游戏。
*   游戏将从游戏树的最后一级开始，并相应地选择值。
*   像下图，游戏是玩家 q 启动的，他会挑终端最左边的值，固定为 beta(？).现在，下一个终端值将与？-价值。如果该值将小于或等于。-值，用当前值替换它？-值，否则不需要替换该值。
*   完成一个部分后，移动实现的？-值，并将其固定为另一个阈值，即？。
*   现在，轮到 P 了，他会挑选最好的最大值。只有在将值与当前值进行比较后，p 才会移动以探索下一部分？-价值。如果值等于或大于当前值？-value，那么只有它将被替换，否则我们将删除这些值。
*   除非没有得到结果，否则将重复这些步骤。
*   因此，上例中被修剪的节点数为**4 个**，MAX 以最大**效用**值赢得游戏，即 **3**

将遵循的规则是:**“必要时浏览节点，否则删除不必要的节点。”**

**注意:**很明显，结果将会有同样的**效用**值，我们可以从极大极小策略中得到。