# Java 记录器

> 原文：<https://www.tutorialandexample.com/java-logger>

日志记录是 Java 的一个重要特性，可以帮助开发人员识别问题。Java 作为编程语言包含了日志方法。它提供了在 Java 1.4 中首次出现的日志 API。可以使用此功能记录日志文件。本节将包括对 Java Logger API 的全面分析。我们还将讨论组件、日志处理程序或附加程序、日志格式化程序或布局、日志级别、Java Logger 类和组件。它展示了如何以有效的方式处理处理程序等等，这涉及到了每个必需的主题。

## Java 日志到底是做什么的？

Java 语言有一个名为 logging 的 API，它使得跟踪程序失败成为可能。当应用程序生成日志调用时，日志记录器会将该事件记录到日志记录中。然后，它发送给适当的处理程序或附加程序。在将日志记录发送到控制台或文件之前，附加程序使用格式化程序或布局对日志记录进行格式化。

## 渴望伐木

*   它提供了应用程序跟踪信息的完整历史。
*   如果在运行应用程序时出现任何严重故障，它会记录下来。

## 日志记录组件

开发人员使用 Java 日志组件来生成日志，并以适当的格式将它们传输到所需的位置。以下三个组件组成了 Java 日志 API:

*   记录器
*   用于日志记录的处理程序或附加程序
*   用于日志记录的布局或格式化程序

### 记录器

Logger 对象接收来自客户端代码的日志请求，并对其进行处理。这些 logger 对象维护他们感兴趣的日志级别，并拒绝对低于该级别的日志的请求。

换句话说，它负责记录日志记录。然后，记录被发送到适当的附加器。

通常，命名实体构成了 Loggers 对象。由点运算符分隔的对象。java.awt、java.awt 等。举几个例子。

名称空间由 LogManager 控制，并且是分层组织的。它必须与打包命名空间对齐匹配。虽然不必精确地坚持它。虽然它不会出现在共享名称空间中，但是我们也可以构建一个匿名日志记录器。

记录器在命名空间中查找父记录器以进行记录。它是日志记录中与当前祖先最相似的命名空间，知道根日志记录器是一个孤儿是很重要的。它从父母那里继承了各种各样的特征，包括:

*   **日志记录的级别**:如果提供了 null，则通过向父级移动来搜索最高的非 null 级别。
*   **处理程序:**任何发送到父处理程序的消息都将被一个记录器记录下来，递归地沿着树向上。
*   ****资源包名称:**如果一个记录器的资源包名称为空，它将递归地沿树向上继承任何父的资源包名称。**

 ****### 用于日志记录的处理程序或附加程序

*   一个 Java 日志记录器可以使用几个处理程序，由于有了 Java 日志 API，这些处理程序可以适当地处理日志。Java 中有五种不同的日志处理程序:
*   **StreamHandler:** 将准备好的日志消息写入输出流。
*   **控制台处理器:**向控制台输出所有准备好的日志信息。
*   ****handler ofile:**日志消息以 XML 格式写入单个文件或不断循环的文件集合。**
*   ****SocketHandler:** 外部 TCP 端口用于写入日志消息。**
*   ****MemoryHandler:** 常驻内存的缓冲日志记录由它管理。ConsoleHandler 和 FileHandler 是 Java 日志 API 提供的两个标准处理程序。Handler 类可以通过创建它或它的任何子类(如 MemoryHandler、StreamHandler 等)的新实例来修改和扩展。).根据日志记录要求，选择附加器。如果您不确定使用哪个附加器，应用程序的有效性可能会受到影响。**

 **### 用于日志记录的布局或格式化程序

用于日志记录的格式化程序或布局用于将数据转换为日志事件并格式化日志消息。Java SE 提供的两个标准格式化程序类如下:

*   简单格式化程序
*   XML 格式器

**简单格式化程序**

由它产生包含广泛信息的文本消息。它创建人类可读的日志消息摘要。为了将日志消息打印到控制台，ConsoleHandler 使用类。例如，随后的控制台消息显示

```
Nov 207, 2022 02:55:55 PM DemoClass main  
Server: There was an exception.
```

**XMLFormatter**

XMLFormatter 以 XML 格式创建日志消息。它记录了 XML 结构的细节。它充当 FileHandler 的默认格式化程序。日志条目显示如下:

```
<?xml version="2.0" encoding="UTF-10" standalone="nope"?>  
<!DOCTTYPE log SYSTEM "logger.dtd">  
<log>  
<record>  
<Date>2022-12-31T11:59:55</Date>  
<millins>1595664378</millins>  
<order>0</order>  
<logger>DemoClass</logger>  
<levels>SEVERE</levels>  
<class3>DemoClass</class3>  
<method1>main</method1>  
<thread2>1</thread2>  
<text>An exception has occurred.</text>  
</record>  
</log> 
```

我们可以通过扩展 Formatter 类来个性化和构造我们自己的 Formatter 类。任何处理程序都可以使用修改后的类。

其他样式，包括纯文本、Syslog、json、html 等。如果您正在使用日志框架，可以使用。

## Java 的日志记录级别

它还管理日志详细信息，同时提供日志消息的重要性和紧急性的一般指示。日志级别的每个对象都有一个整数值。较高的值对应于较高的优先级。总共有九个级别:七个标准日志级别和两个特殊日志级别。前三个日志记录级别(FINEST、FINER 和 FINE)代表广泛的跟踪数据，包括关于应用程序中发生了什么以及应用程序中发生了什么的详细信息。让我们更详细地看一下每个级别的日志记录。

*   **FINEST:** 代表非常彻底的追踪消息。
*   **FINER:** 它代表全面的跟踪消息，记录关于方法的信息以及程序可能抛出的任何异常。
*   好的:在所有这些中，它代表了最重要的信息。
*   **配置:**显示与应用程序设置相关的数据。细节可以包括有多少内存和磁盘空间。
*   **信息:**用户的个人数据被管理员和其他机构使用。
*   **警告:**因用户操作失误而发生。如果用户输入了错误的凭据，应用程序会显示警告。
*   **严重:**当应用程序显示一些严重或严重的问题时，就会发生这种情况。在这种情况下，应用程序无法继续运行。数据库不可用和内存不足是严重级别的两个常见示例。

 **## 建立日志记录级别

可以用下面的句子配置日志记录级别。

```
logger.setLevel(Level.CONFIG); 
```

除了提供关于应用程序设置的信息，前面提到的行还将日志记录级别设置为 CONFIG。此外，它还创建一个日志，该日志从所提供的级别扩展到更高的级别。

如果日志级别设置为 FINE，则输出日志应该是 CONFIG、INFO、WARNING 和 SEVERE。

正如我们在下面演示的那样，我们也可以通过简单地修改记录器的设置将其分配给配置文件:

```
...  
<Loggers>  
<Logger naam="HintLogger" level="message">  
... 
```

## 日志事件

用 Java 记录事件时，您必须指定一个级别，以便快速分类。以下方法可用于指定级别和提及消息:

### 第一种方法

```
logger.log(Level.Message, "Display the information");
```

要打印的液位信息和信息都在前面的句子中给出。

### 第二种方法

```
logger.data("Display information"); 
```

setLevel()方法用于确保 Java 记录器只记录 INFO 级别或更高级别的事件。

## Java 日志管理器

java.util.logging 类包含 LogManager，它是 java 的一个组件。创建和维护记录器实例，并跟踪全局日志记录设置。此外，我们可以使用它来配置我们自己的应用特定的需求。这两项包括在内:

*   命名记录器的分层命名空间。
*   配置文件包含在一组日志控制属性中。

getLogManager()方法可用于获取日志管理器。随着 LogManager 的创建，它被自动初始化。该特性使容器应用程序(如 EJB 容器)能够用自己的子类覆盖默认的 LogManager 类。

## 日志框架

日志框架也可以用来简化日志概念。以下众所周知的日志框架用于日志记录:

*   一个名为 Apache Log4j 的基于 Java 的日志工具是开源的。
*   **SLF4J:Java 的简单日志门面就是它的名字(SLF4J)。对于一些日志框架，包括 Java.util.logging、Log4j 和 Logback，它充当一个抽象层。**
*   ******Logback:** 在 Log4j 版本 2 发布之前，它是作为一个开源项目开发的，作为一个后继项目。************