# 人工智能中的对抗性搜索

> 原文:[https://www . tutorialandexample . com/adversarial-search-in-artificial-intelligence/](https://www.tutorialandexample.com/adversarial-search-in-artificial-intelligence/)

人工智能对抗性搜索(AI adversive search):对抗性搜索(adversive search)是一种**游戏技术**，代理人被一个竞争环境所包围。给代理(多代理)一个冲突的目标。这些代理相互竞争，并试图击败对方，以赢得游戏。这种相互冲突的目标导致了[对抗性搜索](https://www.javatpoint.com/ai-adversarial-search)。这里玩游戏就是讨论那些用到了**人类智力**和**逻辑因素**的游戏，排除了**运气因素**等其他因素。**井字游戏、国际象棋、跳棋**等。是这种没有运气因素起作用，只有头脑起作用的游戏。

从数学上来说，这种搜索是基于博弈论的概念。*‘根据博弈论，一个游戏是两个玩家之间进行的。要完成游戏，一方必须赢得游戏，另一方自动输掉。*T3】

<figure class="wp-block-image">![adversarial search in artificial intelligence](../Images/1c8cc7c38201507d7072d1905717c792.png)</figure>

**获得最佳解决方案所需的技术**

总是需要选择那些在有限时间内提供最佳最优解的算法。因此，我们使用以下技术来满足我们的要求:

*   **剪枝:**一种允许忽略搜索树中不需要的部分的技术，这些不需要的部分对最终结果没有影响。
*   **启发式评估函数:**它允许在到达目标节点之前，在搜索树的每一层近似成本值。

**游戏搜索的要素**

为了玩游戏，我们使用游戏树来了解所有可能的选择，并从中挑选出最好的一个。玩游戏有以下几个要素:

*   **S****<sub>0</sub>****:**游戏开始的初始状态。
*   **玩家:**它定义了当前轮到哪个玩家在该状态下移动。
*   **动作:**它定义了在一个状态中使用的一组合法动作。
*   **RESULT (s，a):** 它是定义移动结果的转换模型。
*   **TERMINAL-TEST (s)** :定义游戏已经结束，返回 true。
*   **UTILITY (s，p):** 它定义了游戏结束时的最终值。这个函数也被称为**目标函数**或**收益函数**。获胜者将获得的价格，即
*   **(-1):** 如果玩家输了。
*   **(+1):** 如果玩家赢了。
*   **(0):** 如果玩家之间出现平局。

***比如说*** *，在**象棋里，井字游戏里，**我们有两三种可能的结果。要么赢，要么输，要么用值 **+1，-1 或 0 来和局。**T9】*

让我们借助为**井字游戏**设计的游戏树来理解这些元素的工作原理。这里，*节点代表游戏状态，边代表玩家的移动。*

<figure class="wp-block-image">![Adversarial Search in Artificial Intelligence](../Images/61f4583e47f3060d34a73313694fb95f.png)</figure>

<figure class="wp-block-table aligncenter">

| **井字游戏的博弈树** |

</figure>

*   **初始状态(S <sub>0</sub> ):** 博弈树中的顶部节点代表了树中的初始状态，并显示了所有可能的选择来挑出一个。
*   **玩家:**有两个玩家， **MAX 和 MIN** 。**麦克斯**通过选择一个最佳走法开始游戏，并将 **X** 放入空的方形盒子中。
*   **动作:**双方玩家都可以在空盒子里随机移动。
*   **结果(s，a):****MIN**和 **MAX** 的走法将决定游戏的胜负。
*   **终端测试:**当所有的空格都被填满时，游戏将进入终止状态。
*   **效用:**最后我们会知道谁赢: **MAX** 或者 **MIN，**并据此给他们价格**。**

**对抗性搜索中的算法类型**

在**普通搜索**中，我们遵循一系列的行动来达到目标或以最佳方式完成游戏。但是在**对抗搜索**中，结果取决于决定游戏结果的玩家。同样明显的是，目标状态的解将是最优解，因为玩家将试图在有限的时间内以最短的路径赢得游戏。

对抗性搜索有以下几种类型:

*   **最小最大算法**
*   **阿尔法-贝塔剪枝。**

**注:**对抗性搜索的类型将在下一节讨论。