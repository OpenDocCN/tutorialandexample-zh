# Java 中的多线程

> 原文:[https://www.tutorialandexample.com/multithreading-in-java/](https://www.tutorialandexample.com/multithreading-in-java/)

**多线程**是**多任务**的一种特殊形式。它负责在单个程序中一次执行多个任务，每个任务都是一个独立的线程。多线程程序由两个或多个可以并发运行的部分组成，每个部分可以处理不同的任务。多线程是一种优化或更好地利用可用资源的技术，尤其是当我们的计算机有多个 CPU 时。多线程增强了应用程序中多任务处理的概念，我们可以将单个应用程序中的特定操作分配到单独的线程中。线程可以在单个进程中并行运行。OS 不仅在不同的程序之间分配处理时间，而且在程序中的每个线程之间分配处理时间。

它使我们能够在同一程序中同时进行多个活动。

多线程的主要重要应用领域有

1.  开发多媒体图形。
2.  来开发动画。
3.  开发电子游戏。
4.  开发网络服务器和应用服务器设置。

注意:与旧语言相比，用 java 开发多线程应用程序非常容易，因为 java 通过丰富的 API 提供了对多线程的内置支持。

### 线的种类有哪些？

系统中创建的两种类型的线程。

*   内核级线程。
*   用户级线程。

### 内核级线程

并发性变得更便宜(更快)，因为一个进程有多个线程，一次执行多个作业。因此，操作系统管理这些线程和进程。内核实现所有的线程操作，操作系统调度内核中的所有线程。操作系统管理的线程被称为内核级线程或轻量级进程。

内核线程是一个可调度的实体，这意味着系统调度程序(内核)处理内核线程。这些线程非常依赖于实现，并且被系统调度器所知。

内核线程是一个内核实体，如进程和中断处理程序；它是由系统调度程序控制的实体。内核线程在一个进程中运行，但是可以被系统中的另一个线程引用。程序员不能直接控制这些线程。这些库提供了用户线程，以便于编写可移植程序。

线程的管理由内核执行，因为它拥有线程的信息。在内核管理的情况下，不需要运行时系统。内核包含一个线程表来跟踪系统中的线程，而不是在每个进程中都有线程表。此外，内核还有传统的进程表来跟踪进程。线程的创建和管理是通过内核的系统调用来完成的。

进程的上下文信息以及进程线程都由内核管理。因此，内核级线程比用户级线程慢。

### 内核级线程的优势:

1.  调度程序决定给包含大量线程的进程比包含少量线程的进程更多的时间，因为内核完全了解所有线程。
2.  在内核级线程的不同处理器上，可以调度同一进程的多个线程。
3.  多线程环境也可以应用于内核例程。
4.  内核级线程被认为更好，尤其是对于经常阻塞的应用程序。
5.  如果内核级线程被阻塞，内核可以调度同一进程的其余线程。

### 内核级线程的缺点:

1.  与用户级线程相比，内核级线程的创建和管理效率较低，速度较慢。内核线程的操作比用户级线程慢几百倍。
2.  因为它管理和调度线程以及进程，并且还为每个线程维护完整的线程控制块(TCB)来维护关于线程的信息，所以存在显著的开销和增加的内核复杂性。

### 用户级线程

内核级线程大大降低了并发性，因为需要分配和初始化的状态更少了。然而，对于细粒度的并发性，内核级线程仍然遭受太多的开销。线程操作仍然需要系统调用。理想情况下，我们要求线程操作和过程调用一样快。内核级线程必须是通用的，以支持所有程序员、语言、运行时等的需求。对于这种细粒度的并发，我们仍然需要尽可能快地执行操作的更便宜的线程。

因此，为了使线程便宜而快速，它们需要在用户级实现。用户级线程很小，比内核级线程快一百倍。运行时系统(用户级库)完全管理用户级线程。创建新线程、在线程之间切换以及同步线程是通过过程调用来完成的，即不涉及内核。内核不知道用户级线程，只在最后管理(处理)它们(即执行它们)，就像它们是单线程进程一样。

在处理多个控制流的程序中，用户线程是程序员使用的实体。处理用户线程的 API 由线程库提供。用户线程仅存在于一个进程中；进程 A 中的用户线程不能引用进程 b 中的用户线程。该库使用专有接口来处理内核线程以执行用户线程。与内核线程接口不同，用户线程 API 是符合 POSIX 标准的可移植编程模型的一部分。因此，在 AIX 系统上创建的多线程程序可以很容易地移植到其他系统上。在其他系统中，用户线程被称为线程，轻量级进程指的是内核线程。

### 用户级线程的优势:

1.  在操作系统上，可以实现用户级线程。
2.  每个线程由一台 PC、寄存器、堆栈和一个小控制块代表，所有这些都存储在用户进程地址空间中。
3.  线程创建、线程切换和线程同步都可以在没有内核干预的情况下完成。
4.  创建用户级线程比内核级线程更容易、更快。
5.  在操作系统上，可以运行用户级线程。
6.  对于用户级线程中的线程切换，不需要内核模式特权。

### 用户级线程的缺点:

1.  由于用户级线程没有很好地与操作系统集成，所以线程对操作系统是不可见的。因此，操作系统会执行一些糟糕的决策，例如使用空闲线程进行进程调度、阻塞其线程发起 I/O 的进程(即使该进程拥有可以运行的线程)以及取消调度使用持有锁的线程的进程。
2.  操作系统内核和线程之间缺乏协调(通信)。因此，无论进程中有一个线程还是 1000 个线程，整个进程都会获得一个一次性切片。
3.  用户级线程所需的非阻塞系统调用。整个进程将在内核 else 中被阻塞，即使进程中还有可运行的线程。
4.  用户级线程中的多线程应用程序无法利用多重处理。
5.  如果一个用户级线程执行阻塞操作，整个进程将被阻塞。

### 用户级线程和内核级线程有什么区别？

| **用户级线程** | **内核级线程** |
| 这些线程的管理和创建速度更快。 | 这些线程的创建和管理速度较慢。 |
| 上下文切换时间更少。 | 上下文切换时间更多。 |
| 如果一个用户级线程执行阻塞操作，那么整个进程都将被阻塞。 | 如果一个内核线程执行阻塞操作，那么另一个线程可以继续执行。 |
| 操作系统不识别用户级线程。 | 操作系统识别内核线程。 |
| 多线程应用程序不能利用多处理。 | 内核例程本身可以是多线程的。 |
| 用户级线程可以在任何操作系统上运行。 | 内核级线程不是通用的，它与特定的操作系统相关。 |
| 用户线程利用用户级的线程库。 | 操作系统支持内核线程的创建。 |

### 多线程模型有哪些？

为了增加多道程序或提高系统的效率，我们正在使用多线程模型。

**多线程模型有三种:**

### 多对一

许多用户级线程被映射到一个内核线程。一个内核线程负责处理许多用户级线程的操作。

线程管理是在用户空间中完成的，这意味着线程的创建和管理是在用户空间中完成的。

<figure class="wp-block-image">![Multithreading in Java](../Images/522e30643c82a239029bf3df6533ea9a.png)</figure>

如果任何一个用户线程进行阻塞调用或者由于某种原因被阻塞，那么整个操作都会被阻塞，内核线程也会因为那个用户线程而被阻塞。例如，在执行过程中，一个线程最终读取了一些无效的内存位置，该线程进行了一个阻塞调用，内核线程也由于这个用户线程而被阻塞。

### 一对一

对于每个用户线程，都有一个内核线程。无论为每个用户线程创建了什么用户线程，内核也会创建一个内核线程，所以每个用户线程都被映射到一个内核线程。

它提供了更多的并发性。如果一个线程发出阻塞调用，则允许剩余的另一个线程运行应用程序或进程，以便用剩余的内核线程完成任务。

<figure class="wp-block-image">![Multithreading in Java2](../Images/fc941426375b1c3c770184d1f129e221.png)</figure>

该模型增加了并发性，但是它增加了操作系统为相应的用户线程创建相应内核的开销。为了管理用户线程，操作系统必须创建许多内核线程。因此，一对一会为每个用户线程创建许多内核线程，从而加重操作系统的负担。创建一个内核线程可能是不可能的，因为管理这些内核线程将再次成为操作系统的开销。

### 多对多

它将许多用户级线程复用到更少或相等数量的内核线程中。一个内核线程将与一个或多个用户线程相关联。在这个模型中，即使一个或多个用户线程被阻塞，其他内核线程也会管理用户线程并执行任务或继续执行任务。

<figure class="wp-block-image">![Multithreading in Java3](../Images/f2ccb153a06621170f2462a74e6a77ed.png)</figure>

用户线程与内核线程是多路复用的，所以一个内核线程可以处理多个用户线程。在这种情况下，即使一个用户线程进行了阻塞调用，其他用户线程也可以在其他内核线程上处理，并且执行继续运行。

这里，线程的调度已经完成，所以内核被调度一个线程来执行，所以如果一个用户线程阻塞调用一个内核线程，那么剩余的用户线程将被调度给其他内核线程。与前两种模型相比，多对多模型提供了更多的并发性，它被认为是多线程的最佳模型。