# Java 中的死锁

> 原文:[https://www.tutorialandexample.com/deadlock-in-java/](https://www.tutorialandexample.com/deadlock-in-java/)

死锁是指两个或更多的进程等待状态去完成它们的任务，但是没有一个进程能做到。在多处理系统和分布式系统中，这是一个很常见的问题。

在 Java 中，死锁是多线程中的一个概念，其中一个线程锁定第二个线程所需的对象，第二个线程锁定第一个线程所需的对象。在这种情况下，两个线程都不能处理自己，于是就产生了一个死锁。

例如，如果一个线程 A 锁定了对象 A，所有其他想要获取对象 A 的线程都会被阻塞。

或者，如果线程 A 想要由线程 B 获得的对象 B 的锁，这两个线程之间就会发生冲突。

在这两种情况下，都会产生死锁。

![Deadlock In Java](../Images/d063ce1b164ff37018bfcf769d43bdfc.png)  

## 死锁的条件

形成死锁所需的条件称为“**科夫曼条件**”，在 **1971** 中给出。这些条件足以造成死锁。

**互斥**

互斥意味着资源应该是不可共享的。一个资源一次只能由一个进程使用，其他任何进程都不能访问该资源。

当一个进程需要分配给其他进程的资源时，就会出现互斥现象，并出现死锁。

在 Java 中，线程之间是互斥的。这意味着在多线程中，只有一个线程会执行自己，而在那个时候，其他线程会停止。

在线程之间互斥的情况下，线程获得的资源变得不可共享。假设如果一个线程 A 正在持有一个资源，另一个线程 B 出来要求得到线程 A 获得的同一个资源；然后，在这种情况下，线程 A 获得的资源是不可共享的，因此线程 B 需要等待轮到它，这会使完成器执行时间变长。如果线程 A 也在等待线程 b 获取的资源，这也会变成死锁情况。

**不抢占**

抢占意味着在进程之间切换或共享资源。无抢占意味着如果一个进程持有一个或多个资源，那么它在任何情况下都不会释放那些资源，直到并且除非它完成它的任务。

在 Java 中，当一个线程被创建，并且资源被分配时，它不会释放它的资源，直到它完全执行。当另一个线程开始执行自己并要求第一个线程获得的资源时，它需要先等待那个线程完成它的执行。在这种情况下，如果等待资源的另一个线程被第一个线程获取，类似地，如果第一个线程正在等待另一个线程获取的资源，那么在这种情况下，两个线程都需要等待对方，因此将会创建死锁。

**保持并等待**

保持和等待是一种情况，其中一个进程持有另一个进程所需的资源，而另一个进程持有第一个进程所需的资源。可以说，他们都是互相握着对方的资源，不准备释放自己的资源。

在 Java 中，在多线程过程中，线程可以访问资源。当其他线程需要另一个线程的资源时，这就造成了线程之间的资源冲突，从而在线程之间产生了死锁状态。

**循环等待**

它可以被定义为一种状态的进程，循环地要求对方的资源。

让我们借助一个表格来理解它。

<figure class="wp-block-table">

| 过程 | 资源占用 | 所需资源 |
| 第一亲代 | R1 | R2 |
| P2 | R2 | R3 |
| P3 | R3 | R1 |

</figure>

这里我们可以看到，P1 进程拥有一个 R1 资源，它需要一个被 P2 进程占用的 R2 资源。P2 进程有一个 R2 资源，它需要一个被 P3 进程占用的 R3 资源。类似地，P3 进程有一个 R3 资源，它需要一个被 P1 资源占用的 R1 资源。

在这里，我们可以看到三个流程的资源需求循环。这被称为循环等待。

在 Java 的多线程中，线程和它们的资源也有同样的情况。在多线程中，一个线程在最开始获得一些资源，然后在那之后，其他线程也请求相同的资源，这为线程造成了死锁情况。

## 死锁的调试

调试死锁并不容易，原因有二。

*   一般来说，当两个线程以正确的方式分配时间片时，这种情况很少发生。
*   它可能涉及两个以上的线程和两个同步对象。

## 处理僵局

处理死锁有不同的方法。但是，处理任何死锁的常见方法是防止这些条件形成死锁。

**忽略死锁**

顾名思义，我们忽略死锁。当且仅当两个死锁之间的时间非常长，并且两个死锁之间的数据丢失不可容忍时，才可以忽略死锁。

**检测死锁**

在多处理系统和分布式系统中，死锁是不可避免的。因此死锁被检测到，然后在算法的帮助下被解决。系统的状态由一个处理死锁的算法持续监控。当死锁发生时，它会根据系统活动重新启动一些进程。它在资源调度器的帮助下重新分配资源，以消除检测到的死锁。

**防止死锁**

防止死锁意味着防止形成死锁所需的四个条件中的任何一个。

*   要删除互斥，我们必须确保没有进程拥有对资源的完全访问权。在这种情况下，一个资源可以同时在多个进程之间共享或切换。这是通过消除互斥来防止死锁发生所必需的。但是，即使消除了互斥，死锁也可能发生。
*   抢占是多处理和分布式系统中难以避免的一个术语。进程必须持有资源一段时间来执行它们的任务。

如果一个进程持有一个资源，并在该资源的帮助下执行一些任务，同时另一个进程请求相同的资源。如果进程释放了资源，它的处理将被中断，如果它不释放资源，另一个进程必须等待轮到它。

**避免死锁**

起初，避免死锁听起来像是忽略或防止死锁。但是和这两个有很大不同。

为了避免死锁，我们向操作系统提供了关于系统中运行的资源的资源需求的先验信息。在将资源分配给进程之前，会仔细分析进程的每个请求，以便在任何情况下都不会导致死锁。

避免死锁使用不同的算法，该算法检查在将资源分配给进程时发生死锁的可能性。

## 纠正僵局

如果检测到死锁，可以使用两种方法进行纠正。

**终止一个进程**

当检测到死锁时，进程终止有两种方法来纠正死锁。终止进程意味着中止进程。我们可以中止系统中所有正在运行的进程，然后重新启动，但主要问题是会浪费进程的时间和处理的数据。

另一种方法不是终止所有资源，而是一个接一个地终止资源，直到死锁被纠正。但是这种方法的主要问题是，我们必须在每次进程终止时检查系统是否仍处于死锁状态，这使得这种方法非常复杂。

**抢占资源**

众所周知，抢占意味着不在其他进程之间共享资源。但是在死锁时，我们从进程中获取资源，并不断地将它们分配给其他资源，直到死锁被打破。