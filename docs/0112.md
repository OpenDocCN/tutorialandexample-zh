# 不知情的搜索策略-人工智能

> 原文:[https://www . tutorialandexample . com/uninformed-search-strategies/](https://www.tutorialandexample.com/uninformed-search-strategies/)

### 广度优先搜索(BFS)

这是一个简单的搜索策略，首先扩展根节点，然后覆盖根节点的所有其他后继节点，进一步扩展下一级节点，搜索继续进行，直到没有找到目标节点。

**BFS** 使用 FIFO(先进先出)顺序首先扩展最浅的(即非深度)节点。因此，新节点(即父节点的子节点)保留在队列中，比新节点浅的旧的未扩展节点首先被扩展。

在 BFS 中，目标测试**(检查当前状态是否为目标状态的测试)**在节点生成时应用于每个节点，而不是在选择节点进行扩展时。

<figure class="aligncenter">![Breadth-first search tree](../Images/f7c9037ea83485fb27955a3fe48830ff.png)

<figcaption>**Breadth-first search tree**</figcaption>

</figure>

在上图中可以看到，节点是从树中的根节点 **A** 开始逐级展开，直到最后一个节点 **I** 为止。所以 BFS 顺序遵循的是:**A->B->C->D->E->F->G->I**。

### BFS 算法

*   将变量**节点**设置为初始状态，即*根节点。*
*   设置变量**目标**，该变量包含*目标状态的值。*
*   逐层遍历每个节点，直到找不到目标状态。
*   在执行循环时，开始按照 ***FIFO*** 的顺序从队列中删除元素。
*   如果找到目标状态，**返回目标状态**，否则继续搜索。

**BFS 的绩效指标如下:**

*   **完整性:**这是一个完整的策略，因为它明确地找到了目标状态。
*   **最优性:**如果每个节点的成本相同，则给出最优解。
*   **空间复杂度:**《BFS》的空间复杂度为 **O(b <sup>d</sup> )** ，即需要巨大的内存量。这里，b 是**分支因子**，d 表示树的**深度/级别**
*   **时间复杂度:**对于大型实例，BFS 到达目标节点需要很长时间。

### BFS 的缺点

*   BFS 最大的缺点是它需要大量的内存空间，因此它是一种内存受限的策略。
*   BFS 采取的是时间搜索策略，因为它横向扩展了节点。

**注:** BFS 逐层扩展节点，即横向扩展，因此也被称为**级搜索技术。**

### 统一成本搜索

与 BFS 不同，这种不知情的搜索基于节点从根节点开始的路径成本来探索节点。它扩展具有最低路径成本 g(n)的节点 n，其中 g(n)是从根节点到节点 n 的总成本。均匀成本搜索与广度优先搜索显著不同，原因有以下两个:

*   首先，目标测试仅在节点被选择用于扩展**时应用于节点，而不是在节点第一次被生成**时应用于节点，因为生成的第一个目标节点可能在次优路径上。
*   第二，仅当找到更好/最优路径时，将目标测试添加到节点。

因此，统一成本搜索以节点的**最优路径成本**的顺序扩展节点，因为在探索任何节点之前，它搜索最优路径。此外，步骤成本为正，因此，当在搜索中添加新节点时，路径永远不会变短。

<figure class="aligncenter">![Uniform-cost search on a binary tree](../Images/f574d2ca9077fa7eb293b5ac1bf707d7.png)</figure>

### 二叉树上的均匀代价搜索

在上图中，可以看到目标状态是 **F** ，开始/初始状态是 **A** 。有三条路径可以到达目标节点。我们需要选择一条最优路径，它可以给出最低的总成本 g(n)。因此， **A- > B- > E- > F** 给出最优路径成本即 **0+1+3+4=8。**

### 统一成本搜索算法

*   将变量**节点**设置为初始状态，即*根节点并展开*。
*   展开根节点后，选择一个路径开销最低的节点并进一步展开。记住，**节点的选择应该给出一个最优的路径代价。**
*   如果目标节点搜索到最优值，返回**目标状态**，否则继续搜索。

**统一成本搜索的性能度量**

*   **完备性:**保证达到目标状态。
*   **最优性:**给出搜索的最优路径代价解。
*   **时空复杂度:**均匀代价搜索最差的时空复杂度是**O(b<sup>1+</sup>****<sup>LC */</sup>****？<sup>？</sup>** **)。**

**注意:**当所有节点的路径开销相同时，其行为类似于 **BFS。**

### 统一成本搜索的缺点

*   它不关心路径达到目标状态所经过的步数。
*   如果存在一条具有无限零成本序列的路径，它可能会陷入无限循环。
*   它努力检查每个节点，寻找成本最低的路径。

### 深度优先搜索

这种搜索策略首先探索最深的节点，然后回溯探索其他节点。它使用基于**、**栈的 **LIFO(后进先出)**顺序，以便展开[搜索树](https://www.tutorialandexample.com/binary-search-tree/)中未展开的节点。搜索进行到树的最深层，在那里它没有后继者。这种搜索将节点扩展到无穷大，即树的深度。

<figure class="aligncenter">![Depth-first search](../Images/0965a2ed5d53732aa121e022f5af0dde.png)</figure>

### DFS 搜索树

在上图中，DFS 从初始节点 **A** (根节点)开始，沿一个方向深入遍历，直到节点 **I** ，然后回溯到 B，以此类推。因此，顺序将是**A->B->D->I->E->C->F->g .**

### DFS 算法

*   将变量**节点**设置为初始状态，即*根节点。*
*   设置变量**目标**，该变量包含*目标状态的值。*
*   通过在一个方向/路径上深入遍历来循环每个节点，以搜索目标节点。
*   在执行循环的同时，开始按照 ***LIFO*** 的顺序从堆栈中移除元素。
*   如果找到目标状态，**返回目标状态**，否则回溯到其他方向展开节点。

**DFS 的绩效衡量**

*   **完备性:** DFS 不保证达到目标状态。
*   **最优性:**它不会给出最优解，因为它会在一个方向上深度扩展节点。
*   **空间复杂度**:只需要存储一条从根节点到叶节点的路径。因此，DFS 具有 **O(bm)** 空间复杂度，其中 b 是**分支因子(即，一个父节点拥有的子节点总数)**，m 是任意路径的**最大长度。**
*   **时间复杂度** : DFS 具有**O(b****<sup>m</sup>****)**时间复杂度。

### DFS 的缺点

*   它可能会陷入无限循环。
*   也有可能达不到目标状态。
*   DFS 没有给出最优的解决方案。

**注意:** DFS 使用**回溯**的概念来探索搜索树中的每个节点。

### 深度受限搜索

这种搜索策略类似于 DFS，但有一点不同。不同之处在于，在深度受限搜索中，我们通过对搜索树的深度施加**深度限制*l*T3】来限制搜索。它不需要探索到无限远。因此，**深度优先搜索是深度受限搜索的一个特例。**极限 l 为无穷大时。**

<figure class="aligncenter">![Depth-limited search on a binary tree](../Images/c276eca3805292effd5d5d50cfc1038d.png)</figure>

**二叉树上的深度受限搜索**

在上图中，**深度限制为 1。**因此，在 **A- > B- > C** DFS 序列中，从根节点 **A** 开始直到节点 **B** 只有级别 0 和 1 得到扩展。它没有给出令人满意的结果，因为我们无法达到目标节点 **I** 。

### 深度受限搜索算法

*   将变量**节点**设置为初始状态，即*根节点。*
*   设置变量**目标**，该变量包含*目标状态的值。*
*   设置一个变量 **LIMIT** ，它带有一个深度限制值。
*   通过以 **DFS** 的方式遍历每个节点，直到深度限制值。
*   在执行循环的同时，开始按照 ***LIFO*** 的顺序从堆栈中移除元素。
*   如果找到目标状态，**返回目标状态**。否则**终止搜索。**

**深度受限搜索的性能度量**

*   **完备性:**深度受限搜索不保证到达目标节点。
*   **最优性:**当它将节点扩展到深度极限时，不会给出最优解。
*   **空间复杂度:**深度受限搜索的空间复杂度为 **O(b** **l** **)。**
*   **时间复杂度:**深度受限搜索的时间复杂度为 **O(b** **<sup>l</sup>** **)。**

### 深度受限搜索的缺点

*   这个搜索策略并不完整。
*   它没有提供最佳解决方案。

**注:**限深搜索以两种失败终止:**标准失败值**表示“无解”，**截止值**表示“限深内无解”

### 迭代深化深度优先搜索/迭代深化搜索

这种搜索是 BFS 和 DFS 的结合，因为 BFS 保证到达目标节点，而 DFS 占用较少的内存空间。因此，迭代深化搜索结合了 BFS 和 DFS 的这两个优点来到达目标节点。它从 **0，1，2** 开始逐渐增加深度限制，并到达目标节点。

<figure class="aligncenter">![Iterative deepening depth-first search/Iterative deepening search](../Images/69583efa259c120b924afbb92df7574f.png)</figure>

上图中，目标节点为 **H** ，初始**深度限制=【0-1】**。因此，它将扩展级别 0 和 1，并以 **A- > B- > C** 序列终止。此外，更改 **depth-limit =[0-3]** ，它将再次将节点从级别 0 扩展到级别 3，并且搜索以**A->B->D->F->E->H**序列终止，其中 **H** 是期望的目标节点。

迭代深化搜索算法

*   按 DFS 顺序浏览节点。
*   用极限值设置一个极限变量。
*   循环每个节点直到极限值，并相应地进一步增加极限值。
*   找到目标状态时终止搜索。

**迭代深化搜索的性能度量**

*   **完备性:**迭代深化搜索可能达到也可能达不到目标状态。
*   **最优性:**并不总是给出最优解。
*   **空间复杂度:**与 BFS 具有相同的空间复杂度，即 **O(b <sup>d</sup> )。**
*   **时间复杂度:**它有 **O(d)** 时间复杂度。

**迭代深化搜索的缺点**

*   迭代深化搜索的缺点是它看起来很浪费，因为它多次生成状态。

**注:**一般在搜索空间较大，解的深度未知时，需要迭代深化搜索。

### 双向搜索

双向搜索背后的策略是同时运行两个搜索**——一个从初始状态向前搜索，另一个从目标的后面搜索**——希望两个搜索在中间相遇。一旦两个搜索彼此相交，双向搜索就终止于目标节点。这个搜索是通过替换目标测试来检查两个搜索是否相交来实现的。因为如果他们这样做了，就意味着找到了解决办法。

**双向搜索的性能度量**

*   **完成:**双向搜索完成。
*   **最优:**给出最优解。
*   **时空复杂度:**双向搜索有**O(b****T5】d/2****)**

### 双向搜索的缺点

*   它需要大量的内存空间。

#### 相关帖子:

*   [人工智能中的约束满足问题](https://www.tutorialandexample.com/constraint-satisfaction-problems-in-artificial-intelligence/)
*   [阿尔法-贝塔剪枝|人工智能](https://www.tutorialandexample.com/alpha-beta-pruning/)
*   [人工智能中的对抗性搜索](https://www.tutorialandexample.com/adversarial-search-in-artificial-intelligence/)
*   [人工智能中的启发式函数](https://www.tutorialandexample.com/heuristic-functions/)
*   [局部搜索算法和优化问题](https://www.tutorialandexample.com/local-search-algorithms-and-optimization-problem/)
*   [知情搜索/启发式搜索](https://www.tutorialandexample.com/informed-search-heuristic-search/)
*   [人工智能中的问题解决](https://www.tutorialandexample.com/problem-solving-in-artificial-intelligence/)
*   [人工智能教程| AI 教程](https://www.tutorialandexample.com/artificial-intelligence-tutorial/)
*   [爬山算法](https://www.tutorialandexample.com/hill-climbing-algorithm/)
*   [一阶逻辑理论](https://www.tutorialandexample.com/theory-of-first-order-logic/)
*   [命题逻辑中的推理规则](https://www.tutorialandexample.com/inference-rules-in-proposition-logic/)