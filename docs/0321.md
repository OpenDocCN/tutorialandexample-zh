# Java 中的内存区域

> 原文：<https://www.tutorialandexample.com/memory-areas-in-java>

让我们来看看 Java 中的内存管理是如何工作的。我们将讨论对象是如何被销毁的，垃圾收集器的工作，由 JVM (Java 虚拟机)管理的东西。

程序员有必要了解内存管理的工作原理，以创建不会崩溃的高性能程序，或者如果崩溃了，他们将知道如何调试和克服崩溃。

在每一种编码语言中，内存管理在内存区域的分配和释放中起着至关重要的作用，因为它需要非常小心。在 Java 中，JVM 和垃圾收集器管理内存分配。

### Java 存储区的结构

JVM 定义了我们运行代码时使用的各种运行时数据区域。有些数据区是在 JVM 启动时创建的，在 JVM 存在的情况下被销毁，而在线程初始化期间创建的数据区在线程存在时被销毁。

### 堆:

*   堆表示内存中存储实际对象的运行时数据区域。它是在虚拟机启动时创建的。
*   内存被分配给每个类实例。堆的大小取决于系统的配置。
*   当使用一个新的关键字时，对象被分配一个堆中的内存区域，但是对象的引用存在于堆栈中。

### 方法领域

*   方法区域存储类结构、方法数据和构造函数字段数据，包括类中使用的特殊方法。
*   它是在 JVM 启动时创建的。
*   Mehtod area 在逻辑上是堆区的一部分，但它可能会也可能不会被垃圾收集。
*   方法的大小可以根据计算的需要固定或扩展，如果方法区域被不必要地使用，则可以收缩。

### JVM 栈

*   每个线程都在创建自己的堆栈的同时创建了自己的堆栈。
*   每个堆栈被分为不同的部分，称为帧。这些框架用于存储数据和部分结果，以及执行动态链接、方法返回值和调度异常。
*   每个堆栈的框架分为三个不同的部分。
    *   局部变量存储区
    *   操作数栈
    *   帧数据。
*   所有将要存储在局部变量存储区中的局部变量，将要处理的变量上的任何操作都存储在操作数堆栈中，如果在方法执行期间出现任何异常，那么这些异常将存储在帧数据中。
*   堆栈可以是固定大小或动态的。它可以在堆栈创建期间独立选择。

### 本机方法堆栈

本机方法堆栈是用不同于 Java 编程语言的语言编写的堆栈。这些内存区域通常是在创建线程时分配给每个线程的。这个内存区域的大小可以是固定的，也可以是动态的。

### 程序计数器(PC)寄存器

*   它存储当前正在执行的 Java 虚拟机指令的地址。
*   在 Java 中，每个线程都有自己的 pc 寄存器。
*   因为 Java 应用程序包含一些本地库。如果应用程序中的方法不是本地的(即，用 Java 编写的)，则程序计数器包含当前正在执行的 JVM 指令的地址，如果是本地的，则 PC 寄存器的值是未定义的。

### 垃圾收集器的工作

JVM 使用这个过程来自动分配和释放内存。垃圾收集器分以下三步工作。

**标记**-识别哪些物体不在使用中

**正常删除-** 未使用的已识别对象已从堆中移除。

**删除和压缩-** 一旦未使用的对象从堆中移除，内存将被自动分配，这些内存分配被分组在一起，以便将来内存分配会更快。

压缩有助于我们将内存分组在一起，因此新内存的分配将会增加。

### 垃圾收集器的类型

串行垃圾收集器- 它的工作原理是保存所有的应用程序线程。它适用于单线程环境。它的一个主要缺点是在垃圾收集期间冻结了所有的应用程序线程。这就是它不适合服务器环境的原因。我们可能只在简单的命令行程序中使用它。

**并行垃圾收集器-** 也称为吞吐量收集器。它是 JVM 的默认垃圾收集器。它使用多线程进行垃圾收集，但在执行垃圾收集时，它也会冻结所有应用程序线程。

**CMS 垃圾收集器-** CMS 代表并发标记清除。它使用多个线程来扫描堆内存中未使用的对象，然后移除标记的实例。它保存应用程序线程，同时在永久生成空间中标记被引用的对象，并且在进行垃圾收集时，如果在堆内存中有任何并行的机会。

与并行垃圾收集器相比，它使用更多的 CPU 来确保更好的应用程序吞吐量。

**G1 垃圾收集器:**有大堆内存区域时使用。G1 将堆内存分成多个区域，并将未使用的内存区域并行分组。它还会在回收内存后立即压缩空闲堆空间。

System.gc()和 Runtime.gc()是向 Java 虚拟机显式请求垃圾收集的方法。