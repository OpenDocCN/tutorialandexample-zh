# Java 中的运算符

> 原文：<https://www.tutorialandexample.com/operators-in-java>

Java 提供了一个很好的操作员环境。这些运算符分为四个不同的组，即算术、按位、关系和逻辑。还有其他操作符可以用来处理一些不寻常的情况。

下面是不同类型运算符的详细描述。

### 算术运算符

它们在数学表达式中的使用类似于在代数中的使用。以下是算术运算符列表:

| 操作员 | 结果 |
| + | 加法(也指一元加号) |
| - | 减法(也称一元减号) |
| * | 增加 |
| / | 分开 |
| % | 系数 |
| ++ | 增量 |
| += | 加法赋值 |
| -= | 减法赋值 |
| *= | 乘法赋值 |
| /= | 分部分配 |
| %= | 模数分配 |
| - | 减量 |

算术运算符的操作数必须定义为 integer 类型以便处理，我们也可以在 char 类型上使用它们，因为 char 类型是 int 类型的子集。

**基本算术运算符(加、减、除和乘)。**

基本算术运算符的行为类似于数值类型的代数运算。一元减号(-)运算符减去其单个操作数，一元加号(+)运算符返回其操作数的赋值。

**模数运算符(%)**

该运算符返回除法运算的余数。我们也可以将它应用于浮点类型。

### 复合赋值运算符

这些运算符用于将算术运算与赋值结合起来。例如:

a = a+10；

我们可以将上面的语句改写为复合赋值运算符，如下所示:

a+= 10；

在这种情况下,“a”的值增加了 4。

a = a % 2；

改写为:

a % = 2；

在这种情况下，将获得“a/2”的余数，并将该值放回变量“a”中。

复合赋值操作符是“速记”,所以它节省了我们一点打字的时间。

### 递增和递减运算符

++和–是 Java 的递增和递减运算符。递增运算符将其操作数增加 1，递减运算符将其操作数减少 1。

x = x+1；可以用增量运算符写成 x++。

同样的，

x = x-1；可以用减量运算符写成 x -。

这些运算符以后缀(a++)和前缀(++)的形式出现。它们之间没有区别，但是当我们在大表达式中使用它们时，它们之间的区别就出现了，比如在循环和条件语句中。在前缀形式中，在获得用于表达式的值之前，操作数递增或递减。在后缀形式中，操作数中已经存在的值被用在表达式中，然后被修改。

例如:

x = 10

y = ++ x；

在这种情况下，y 的值设置为 11，因为增量发生在 x 赋给 y 之前。

然而，当我们应用后缀增量时，

x = 4；

y = x++；

在这种情况下，y 的值保持为 4，因为 x 的值是在增量之前获得的。

### 按位运算符

按位运算符处理操作数的各个位。它可以用于任何整数类型。以下是按位运算符列表:

| **操作员** | **结果** | **描述** |
| ~ | 按位一元非 | 该运算符反转操作数的所有位。它反转其操作数的所有位。例如，48 (00110000)变成 207 (11001111)。 |
| & | 按位 AND | 如果两个操作数都是 1，则它返回 1 位，在所有其他情况下都生成 0。例如 00110000 00010001<sup>-</sup>00010000 |
| &#124; | 按位或 | 它组合位，当且仅当两位都为 0 时返回 0。在所有其他情况下，它返回 1。例如 00110000 00010001 - 00110001 |
| ^ | 按位异或 | 它组合位，当且仅当恰好一个操作数为 1 时返回 1 位，在所有其他情况下，它返回 0。例如 00101010 00001111 - 00100101 |
| >> | 右移 | 右移位运算符将所有位向右移位指定的次数。可以写成*“值> > pos”的形式。*这里， *pos* 表示位置数，*值为需要移动的*值，例如 00100011 > > 2 00001000 |
| >>> | 右移零填充 | 这也称为无符号右移运算符，它总是将零移至高位。例如 111111111 > > > 3 00011111 |
| << | 左移位 | 它将所有的位向左移位指定的次数。以“*值< <位置*”的形式书写。这里，*位置*指定要移动的位置数量和*值中的数值。* |
| &= | 按位 AND 赋值 | 上述所有运算符都具有类似于复合算术运算符的复合形式。它将赋值与按位运算结合起来。例如“a= a>>4”将写成“a >>= 4” |
| &#124;= | 按位 OR 赋值 |
| = | 按位异或赋值 |
| >>= | 右移赋值 |
| >>>= | 右移零填充赋值 |
| <<= | 左移赋值 |

这些运算符处理整数中的位。不同位宽的二进制数表示整数类型。我们用一个例子来理解。

二进制中 48 的字节值是 00110000，每个位置代表 2 的幂，从最右位的 2 <sup>0</sup> 开始。接下来是 2 <sup>1</sup> 继续向左 2 <sup>2</sup> 或 4，然后是 8、16、32。因此，48 在位置 32 和 16 处设置了 1 位，因此 48 是 32+16 的和。

显示每个按位逻辑运算结果的表。

| **答** | **B** | **A &#124; B** | **甲&乙** | **甲^乙** | **~A** |
| Zero | Zero | Zero | Zero | Zero | one |
| one | Zero | one | Zero | one | Zero |
| Zero | one | one | Zero | one | one |
| one | one | one | one | Zero | Zero |

### 关系运算符

这些运算符决定操作数之间的关系，如相等和排序。

| **操作员** | **结果** | **描述** |
| == | 等于 | 如果操作数相等，则返回 true，否则返回 false。 |
| ！= | 不等于 | 如果操作数不相等，则返回 true，否则返回 false。 |
| > | 大于 | 如果一个操作数大于另一个操作数，则返回 true，否则返回 false。 |
| < | 不到 | 如果一个操作数小于另一个操作数，则返回 true，否则返回 false。 |
| >= | 大于或等于 | 如果一个操作数大于或等于另一个操作数，则返回 true，否则返回 false。 |
| <= | 小于或等于 | 如果一个操作数小于或等于另一个操作数，则返回 true，否则返回 false。 |

### 布尔逻辑运算符

这些运算符只对布尔操作数进行运算。它将两个布尔值组合起来，形成结果布尔值。

| **操作员** | **结果** | **描述** |
| & | 逻辑与 | 如果两个操作数都为真，则返回真，否则返回假 |
| &#124; | 逻辑或 | 当且仅当两位都为零时，它返回 False，在所有其他情况下，它返回 true。 |
| ^ | 逻辑异或(异或) | 当且仅当只有一个操作数为真时，它返回真，在所有其他情况下，它返回假。 |
| &#124;&#124; | 短路或 | 如果它的一个或两个操作数为真，则返回真，否则返回假。 |
| && | 短路和 | 如果两个操作数都为真，那么只有它返回真。 |
| ！ | 逻辑一元非 | 它对单个操作数进行运算，并返回该操作数的倒数。假则为真，真则为假。 |
| == | 等于 | 它检查两个操作数的值是否相等，如果相等，则返回 true。 |
| ！= | 不等于 | 它检查左边的操作数是否不等于右边的操作数。 |
| ？： | 三元 if-then-else | 它以“表达式 1”的形式书写。表达 2:表达 3”。第一个表达式计算为布尔值，如果表达式 1 为真，则计算第二个表达式，否则计算第三个表达式。 |

下表显示了每个逻辑操作的效果:

| **答** | **B** | **A&#124;B** | **甲&乙** | **A^B** | **！答** |
| 错误的 | 错误的 | 错误的 | 错误的 | 错误的 | 真实的 |
| 真实的 | 错误的 | 真实的 | 错误的 | 真实的 | 错误的 |
| 错误的 | 真实的 | 真实的 | 错误的 | 真实的 | 真实的 |
| 真实的 | 真实的 | 真实的 | 真实的 | 错误的 | 错误的 |