# Java 17 有什么新特性？

> 原文:[https://www.tutorialandexample.com/what-is-new-in-java-17](https://www.tutorialandexample.com/what-is-new-in-java-17)

Java 17 LTS 是 Java SE 平台的最新长期支持版本。根据代表长期支持的 Oracle 免费条款和条件许可证，JDK 17 二进制文件可在生产中免费使用，并可免费再分发。2021 年 9 月 15 日，见证了它的发布。

<figure class="wp-block-image">![What is new in Java 17](../Images/a1db8cbc797b2330553bbc6dfe243d2a.png)</figure>

当一个人习惯并理解一个设备的工作时，就不会有重复的想法和很少的释放。JDK17 开放 LTS 版本包括开发工具、库、Java 虚拟机和其他文件。我们在每个版本中都添加了新的特性，但是我们也必须注意那些被改变或删除的特性。在继续安装过程或更新它之前，让我们来谈谈开放 LTS 版本的发展。

<figure class="wp-block-image">![What is new in Java 17](../Images/e351a75585b93bb2374e58a30871cb37.png)</figure>

## 开放 LTS Java 版本的发展

到目前为止，它一直很好，但是当前的版本表明 Java 在 It 领域的受欢迎程度正在迅速上升。想想当我们不得不等待新的 Java 版本时，比如 2006 年到 2012 年的 Java 6，2013 年到 2014 年的 Java 7，以及引入了最受欢迎的 lambda 流和流概念的 Java 8。未来，我们现在经历频繁的新 Java 发布，比如 2017 年推出 Java 9，2018 年推出 Java 10，同年内推出 Java 11。然而，这次 Java 在这个领域有很强的根基，因为大多数企业选择它作为他们开发的主要语言，并要求工人具备一定的技能。

我们可以勾画出每个它肯定会出现的简短新版本的结构；因此，我们会在 2019 年得到 Java 12 和 Java 13 吗？众所周知，这个程序代码是由 Oracle technologies 管理、设计和维护的，所以这家公司已经显著扩张。到 2020 年，每六个月发布一次新的 Java LTS 将成为标准惯例，这导致了那一年 Java 14 和 Java 15 的发布。目前，Java 16 是最新的 LTS；然而，由于快速增长，2021 年 9 月 15 日宣布的新 LTS Java 17 预计将很快发布。

## java 17 的特性

每个人都渴望这个版本中的重大更新，以促进工作流程。尽管如此，开发人员应该会不高兴，因为没有对主要版本进行任何重要的版本检查，正如 JDK 改进提案所示，也称为 JEPS，如下所示:

### JEP 415:特定于上下文的反序列化过滤器

允许应用程序通过 JVM 范围的过滤器构建器设置特定于上下文和连续选择的反序列化过滤，该过滤器构建器为每个攻击者选择一个过滤器，可以利用该操作。

动机:

*   因为输入数据流的信息经常通过未被识别或未被认证的客户端访问，所以对未知数据的抽象本质上是一个危险的过程。
*   避免序列化威胁的关键是阻止任何类的实例的反序列化，这将禁止直接或间接执行该类的方法。
*   通过适当地构造流，黑客可以恶意地执行任何类的代码。如果对象构建包括改变状态或启动其他活动的副作用，应用程序组件、库对象和 Java 运行时的安全性可能会受到挑战。

### JEP 414: Vector API *(* 第二孵化器 *)*

JDK 17 的 vector API 在效率和实现方面得到了增强，包括用于将字节向量转换为布尔数组和从布尔数组转换出来的菜单。

目标:

*   简洁明了的 API:该 API 必须能够快速表示大范围的矢量计算。
*   独立于平台:API 必须能够在一系列支持向量运算的 CPU 设计上实现。
*   x64 和 AArch64 平台上运行时编译的速度和可靠性
*   正常降级:如果不能正确地将矢量计算转换为矢量命令，可能会发出警告。

### JEP 412:外部函数和内存 API(孵化器)

JEP 的这个提议是对外存储器访问 API 和本地编译器 API 的发展，这两个 API 是以前开发的。这已经是 Java 14、15 和 16 的主题

目标:

java 本地接口旨在取代更强大的 Java 程序开发方法，因为它对用户更友好(JNI)。

**性能**:性能堪比已经可用的 API，如 JNI 或 sun。杂项

不太可能，如果不是更糟的话。效率。

**通用:**提供了使用不同外部内存类型的方法，如原生内存、持久内存、堆内存，以及适应平台未来变化的手段(如 x86 32 位)和用 C 之外的语言编写的导入函数(如 C++，FORTAN)。

**安全性:**只有当软件开发人员或最终用户选择禁用默认的、不安全的动作时，才禁用这些动作。

### JEP 411:反对删除安全管理器

从 Java 1.0 开始，安全管理器就已经存在了。然而，多年来，它几乎从未被利用过。安全管理器在 Java 17 中已停止使用，并将在更高版本中被过时的 Applet API 淘汰，以改进 Java (JEP 398)。

目标:

*   让开发人员为 Java 即将发布的版本做好准备，消除安全管理器。
*   如果用户的 Java 软件依赖于安全管理器，则发送警告。
*   检查是否有必要创建新的 API 或其他技术来处理安全管理器的特殊、受限的使用场景，包括阻塞 System::exit。

### JEP 410:删除实验性的 AOT 和 JIT 编译器

即使使用了 Graal translator，也要维护实验性的 Servlet JVM translator api (JVMCI ),这样程序员就可以继续利用外部编译器版本进行 JIT 处理(GraalVM)。

动机:JDK 9 现在包含了一个叫做向前编译的新功能(jaotc 工具)。jaotc 使用 Java 创建的 Graal 编译器进行 AOT 编译。因为这些实验性的品质还没有被应用，所以人们正在做大量的工作来维持和增强它们。甲骨文推出的 JDK 16 版本中没有这些功能，但没有人提出异议。

### JEP 407:删除 RMI 激活

剩下的远程方法调用(RMI)必须保留，但是会消除激活机制。不再需要 RMI 激活方法，因为它不再是必需的。在 Java SE 15 的 JEP 385 中，它被标记为不推荐使用并建议删除。

### JEP 406:交换机的模式匹配(预览)

通过扩展 Java 的模式语言，switches 的模板匹配允许根据广泛的模式来验证 switching 表达式和语句，每个模式都有不同的操作。它能够简单安全地表达复杂的面向数据的查询。

Instanceof 在 JDK 16 中得到增强，包括了类型模式和模式识别。通过建议的小扩展，习语的常见实例变得更简单了。

目标:

*   通过使模式出现在 case 标签中，切换短语和语句变得更有表现力和更有用。
*   如果有必要，让历史转折点的可忽略性降低。
*   将引入另外两种模式:

1.使用任意布尔表达式和保护模式可以改进模板匹配算法。

2.带括号的模式:解决处理问题。

*   确保所有当前的 switch 短语和句子具有相同的含义，并且执行时没有改动。

### JEP 403:强封装 JDK 内部

将所有 JDK 内部组件严密封闭，除了太阳等相关组件。杂项不安全。从 JDK 9 到 JDK 16，用统一的命令参数放松内部组件的强封装是不可行的。

### JEP 398:反对删除小应用程序 API

因为所有的在线浏览器厂商要么已经停止支持 Java 浏览器插件，要么甚至已经制定了这样做的计划，所以 Applet API 本质上是没有用的。Applet API 没有被更快地移除，尽管它在 Java 9 中被禁止了。

### JEP 391: macOS/AArch64 端口

根据未来需求，将 JDK 移植到新的 macOS/AArch64 平台。

动机:

*   苹果选择将其笔记本电脑从 x64 转换到 AArch64。已经有一个 AArch64 版本的 Java for Linux，但是现在工作是在 Windows 端口上完成的。
*   由于简化标准(如程序二进制接口和受限程序计数器集)的差异，软件工程师希望通过应用条件编译(通常在 JDK 港口)从所有这些传输中利用 AArch64 软件。
*   预集成验证可以降低 MacOS/AArch64 的更改将现有的 Linux/AArch64、Windows/AArch64 和 MacOS/x64 版本分开的风险。

### JEP 306:恢复总是严格的浮点语义

使浮点过程同样严格，而不是同时具有强浮点语义(strictfp)和完全不同的普通浮点含义。在 Java SE 1.2 中添加显式和基本浮点模式会将语言和虚拟机恢复到它们以前的浮点含义。