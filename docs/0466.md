# Java 垃圾收集

> 原文:[https://www.tutorialandexample.com/java-garbage-collection/](https://www.tutorialandexample.com/java-garbage-collection/)

**Java 垃圾收集**

在 Java 中，未被引用的对象被视为垃圾。运行时自动回收未使用内存的过程被称为 **Java 垃圾收集**。换句话说，Java 垃圾收集用于销毁引用较少或未使用的对象。在这一节中，我们将讨论什么是 Java 中的垃圾收集。

### 什么是 Java 垃圾收集？

*   Java 垃圾收集是 Java 中使用的一个特性，它通过销毁未引用的对象来释放运行时未使用的内存。
*   为了在 C 中实现同样的功能，必须使用 *free()* 函数，而在 C++中使用了 *delete()* 函数。
*   但在 Java 中，垃圾收集器会在程序执行时自动运行。
*   垃圾收集器驻留在 JVM (Java 虚拟机)中。

然而，在 Java 中，垃圾收集是自动完成的。因此，与 C 和 C++相比，Java 有更好的内存管理。

### 为什么需要 Java 垃圾收集？

在像 C++这样的语言中，创建和销毁对象是程序员的责任。很多时候，我们发现程序员创建了对象，却忘记了销毁对象。因为这个疏忽，在特定的时间点，会出现内存不足的情况来创建更多的对象，而这可能会导致程序因为 **OutOfMemoryErrors** 而异常终止。因此，为了消除这种错误，Java 中引入了垃圾收集，它自动工作并销毁不可达或引用较少的对象。

 **堆内存有如下两种类型的对象:

1.  **活对象:**活在堆内存中并引用任何对象的对象称为活对象。
2.  **死对象:**不再被分配到任何地方的对象称为死对象。

### 对象是如何解引用的？

我们可以使用以下方法使未使用的对象对垃圾收集有效:

1.  **通过使参考为空**

考虑这个例子，一个名为 Employee 的类被声明有一个名为 **emp** 的对象。

```
 public class Employee
 {
 //statements
 Employee emp= new Employee();
 emp= null;
 } 
```

第二行代码使对象 emp 被取消引用。

*   **将旧参考分配给新参考:**

考虑这个例子，一个名为 **Employee** 的类被声明有两个名为 emp1 和 emp2 的对象。

```
 public class Employee
 {
 //statements
 Employee emp1 = new Employee();
 Employee emp2 = new Employee();
 emp1=emp2;
 } 
```

在上面的代码片段中，最后一条语句将对象 emp2 重新分配给了 emp1。这意味着对象 emp1 可以从内存中删除，因为它没有任何新的参考。

*   **使用匿名对象**

考虑这个例子，一个名为“Employee”的类被声明为具有一个名为 emp 的对象。

```
new Employee();
```

该对象没有名称，因此对于垃圾收集是有效的。

### Java 垃圾收集器是如何工作的？

Java 垃圾收集器在 JVM (Java 虚拟机)内部运行。每个 JVM 都有自己版本的垃圾收集器。垃圾收集器必须满足标准的 JVM 规范，即处理存储在内存堆中的对象，识别不可到达的对象，销毁它们，并再次压缩内存。

Oracle 提供了一个名为 **HotSpot** 的 JVM。它有一个强大而成熟的垃圾收集选项。它遵循与其他垃圾收集器相同的过程。它标识未被引用的对象，并将这些对象标记为垃圾收集。之后，它删除它们，最后在堆内存上执行碎片整理。以便将剩余的对象压缩到内存堆开始处的连续内存空间中。

<figure class="wp-block-image size-large">![Java Garbage Collection](../Images/b3a55b3ebab7989c526833b487d57194.png)</figure>

内存堆分为三个部分:

1.  **年轻一代:**

新创建的对象是年轻一代的。它分为两部分，即伊甸园和幸存者空间。在 Eden 中，新生成的对象被存储，而幸存空间 S0 和 S1 拥有那些通过了第一个垃圾收集周期的对象。在这一代中执行的垃圾收集是一个次要的垃圾收集事件。

*   **老一代:**

程序中不再使用的对象从年轻一代转移到老一代。这些对象的移除被称为主要垃圾收集事件。

*   **永久生成:**

由不同的类和方法组成的元数据被认为是永久的一代。移除未使用的类会导致永久的垃圾收集。

 **### Java 垃圾收集的优势

1.  正如我们所知，像 C 和 C++这样的编程语言需要手动处理内存管理，这就变得非常麻烦。但是 Java 确实在 JVM 的帮助下自动执行这个功能。因此，程序员不需要负责内存管理。
2.  如果程序包含取消引用的内存对象，可能会导致长时间内存耗尽。
3.  垃圾收集减少了某些错误，如悬空指针错误、内存泄漏和双重释放错误。

### Java 垃圾收集的缺点

1.  垃圾收集器停止整个程序的执行，以便搜索和收集垃圾对象。在大型程序的情况下，这可能会导致较长的暂停，有时用户可能会注意到这一点。
2.  我们永远不知道垃圾收集器将在何时运行以及运行多长时间来执行其任务。它可能会影响软件的性能。

在本节中，我们已经讨论了 Java 垃圾收集及其工作原理。在下一节中，我们将讨论 Java gc()。****