# Java 中的堆栈与堆

> 原文:[https://www.tutorialandexample.com/stack-vs-heap-in-java](https://www.tutorialandexample.com/stack-vs-heap-in-java)

在 Java 中，每当我们声明一个对象或创建一个变量时，不管是实例变量、局部变量还是静态变量，都会使用一定的内存来存储数据。数据量或大小由声明的数据类型决定。在 Java 中，有两种类型的数据，原语和非原语。

**原始数据类型:**

<figure class="wp-block-table">

| **类型** | **大小(以比特为单位)** |
| 字节 | eight |
| 短的 | Sixteen |
| （同 Internationalorganizations）国际组织 | Thirty-two |
| 长的 | Sixty-four |
| 漂浮物 | Thirty-two |
| 两倍 | Sixty-four |
| 茶 | Sixteen |
| 布尔型 | one |

</figure>

**非原始数据类型:**

1.  班级
2.  目标
3.  线
4.  排列
5.  连接

原始数据类型和非原始数据类型之间有显著的区别，如下所示。

1.  原始数据类型被初始化和声明，同时保持首字母为小写。相反，非原语数据类型在初始化和声明时，第一个字母保持大写。因为非原语数据类型在 Java 中被当作对象。例如:

```
String st = "Sahil"; // non- primitive data type
int a = 100;        //primitive  data type 
```

*   原始数据类型中的变量一次只能存储一个值，而非原始数据类型允许我们存储许多相同或不同类型的值。

*   对于基本类型变量，堆栈保留所有数据，而对于引用类型，堆栈保存一个指向堆上对象的指针。

Java 的内存管理在它的功能中起着重要的作用。Java 虚拟机正确地使用内存来执行程序。因此，为了做到这一点，Java 中的内存分为以下类型:堆栈内存和堆内存。

### 栈存储器

堆栈内存也称为 Java 的临时内存，存储变量和方法执行的顺序。它使用线性数据结构。堆栈实现了后进先出顺序的概念。为了理解栈是如何工作的，想象一堆书。把躺在这堆书中间的书拿出来的唯一方法是把它上面的书一本一本拿出来。

类似地，stack 将数据存储在一个堆或堆栈中。要访问底部的数据，您需要删除上述所有数据。它实现了以下接口。

*   目录
*   可迭代的
*   收藏品
*   可克隆的
*   随机存取
*   可序列化

它执行以下操作:

**空()**

这是一个返回类型方法；如果堆栈为空，则返回 true。

**peek ()**

这是一个返回栈顶元素的返回类型函数。当堆栈为空时，这个函数抛出一个 EmptyStackException。

**pop ()**

这个返回类型函数返回栈顶元素。当堆栈为空时，该方法调用 **EmptyStackException** 。

**push ()**

向堆栈顶部添加新元素。

### 堆内存

它在我们需要存储对象类和动态分配内存时使用。内存是在 Java 虚拟机启动其功能时创建的，分配的大小可能会增加或减少。每当创建或声明一个新对象时，在堆内存中为它分配空间，而同一对象的引用变量存储在堆栈内存中。与堆栈不同，堆内存不以任何顺序存储数据，也就是说，它不连续存储内存。它有一个叫做垃圾收集器的特性。它会删除所有不再使用的对象。当堆内存没有空间存储新对象时，它调用 Java.lang.OutOfMemoryError。

```
String arr = new String ();
arr = "Sahil Deshmukh"; 
```

在上面的代码中，引用变量 arr 存储在堆栈内存中，其值 Sahil Deshmukh 存储在堆内存中。堆内存进一步分为以下几个部分:-

*   永久世代
*   代码缓存
*   年轻一代
*   老一代
*   幸存者空间

## 堆栈和堆的区别

<figure class="wp-block-table">

| **堆栈内存** | **堆内存** |
| 它充当 Java 的随机访问内存，存储变量、方法和引用变量。 | 它储存物品。 |
| 它实现了后进先出顺序。 | 它不实现任何顺序，而是动态分配内存。 |
| 不允许用户更改或操作内存。 | 用户可以更改内存。 |
| 它在分配内存方面相对较快。 | 它在分配内存方面相对较快。 |
| 它在尺寸上相对较小。 | 它比较大。 |
| 它不断地分配内存。 | 它随机分配内存。 |
| 它是线程安全的，因为每个线程都有自己的堆栈。 | 正确的代码同步至关重要，因为它不是线程安全的。 |
| 当栈的大小达到极限时，它抛出 Java.lang.StackOverFlowError。 | 当堆内存没有空间存储新对象时，它调用 Java.lang.OutOfMemoryError。 |
| 只要当前方法是活动的，堆栈内存就存在。 | 一旦当前应用程序关闭，堆空间也会关闭。 |

</figure>